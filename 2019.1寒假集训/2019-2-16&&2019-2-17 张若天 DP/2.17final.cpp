
单调队列：
1. 插入一个元素到当前集合 <-x   <- x-tag
2. 删除一个元素（删除须按照插入顺序） 
3. 查询最大值 mx   mx+tag

4*. 当前集合内所有元素统一加一个数 +x  tag+=x

int tag; // 当前集合里面的数字总共加了多少 

多重背包：

f[i][j] = max_k (f[i-1][j-v[i]*k] + w[i]*k)
0 <= k <= a[i]

体积 3
价值 5
数量 3
 

f[i-1][j]
j = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14

j
1. mod v[i]
2. 删除  超过a[i] 的状态  j-v[i]*a[i]
4. 加入 j-v[i] 状态 
3. 队列内所有元素 + w[i]
5. 取队列max， 
 
log 


f[i] = max_k (f[k])  + xxx
L[i] <= k <= R[i] 

L[i]单调递增，R[i]单调递增， 用单调队列 维护每个L[i], R[i]区间 
O(n^2) -> O(n)

不满足，L[i]单调递增，R[i]单调递增， 用线段树来维护 每个L[i], R[i]区间
O(n^2) -> O(nlogn)

LIS, 花匠 


树的直径： 
1. 两遍bfs/dfs
x -> y -> z
y,z 
2. 树上DP
 
 以每个点为根的子树作为状态
  
直径： 
f[i]  在以i为根的子树 从i出发的最长链 
1. 初始条件
2. 递推 

max 对于每个节点， 孩子最长链 最大值+次大值
f[i]
 
联和权值 


dfs
和某个点距离为1的点

两两
 
 


   3 21 4 234 2342 233 34

2342*234
(a+b)^2 = a^2 + b^2 +2ab

(a+b+c+d)^2 =  
(a+b+c+d)(a+b+c+d)

int a[]
int sum[]
for(int i=1;i<=n;i++){
	ans += a[i]*sum[i-1];
	sum[i]=sum[i-1]+a[i];	
}
ans*=2 


/2  10007

10007*2

2*999

/8


/k
mod m
m不是素数
0, 1, 2,..., m-1 

/k  k比较小

mod  mk
0, k, 2k, ... ,(m-1)k

/k

 
f[i][0/1]  前i个数字，最后数字选/不选 最大快乐值

f[i][0] <- max(f[i-1][0],f[i-1][1])
f[i][1] <- f[i-1][0] + r[i] 


f[i][0] <- j是i的某个孩子 +=max(f[j][0],f[j][1]) 
f[i][1] <- sum(f[j][0]) + r[i]

f[x][0] <- -oo

*****


0, 10^k -1

0, x

0, 12345

0~12345
0, 9999 //
10000, 12345
10000, 10999
11000, 11999
12000, 12099
12100, 12199
12200, 12299
12300, 12309
12310, 12319
12320, 12329
12330, 12339
12340, 12341, 12342, 12343, 12345

 
1. 预处理 0~10^k-1 带/不带前导0 对应问题的答案
2. 划分成一些区间 分为固定部分，完整遍历10^k部分
固定部分： 暴力 * 次数 10^k
完整遍历10^k: 使用预处理信息
处理跨越的情况

****

f[i] = 0 f[i-1] + f[i-2] + 3f[i-3]

f[i+1] = 0 f[i] + f[i-1] + 3 f[i-2]

N = 1


  插头DP，基于连通性的状态压缩动态规划(轮廓线)
 




f[i][j] 填到第i行，j

int calc(int k,int j){
	上一行状态 为k ， 当前状态j，
}
for(int i=1;i<=n;i++){
	for(int j=0;j<(1<<m);j++){
		//f[i][j]
		//
		for(int k=0;k<(1<<m);k++){
			// f[i-1][k]
			// f[i][j]
			if(calc(k,j))
				f[i][j] += f[i-1][k];
		}
	}
}

5 3
1 1 3
1 2 2

6 2
1 5
2 4
3 3


f[i][j]  将i划分成j个数字的方案数

f[n][k]   <- f[n-1][k-1]
          <- f[n-k][k]

划分数


将 n 划分成若干奇正整数之和的划分数
f[n][k]   <- f[n-1][k-1]
          <- f[n-2*k][k]

//
// 不允许数字相同 
f[n][k]   <- f[n-k][k-1]
          <- f[n-k][k]
          
          
//  f[n-n*(n-1)/2][k]



斜率优化

x[j]  f[j]

f[i] = max(2*f[j]) + a[i]
j<i


f[i] = max(a[i]*x[j]  )
前缀 max[j]
 

f[i] = max(a[i]*x[j] +b[i]*y[j] )
f[i] = max(g[j])
// 当i固定
g[j] = a[i]*x[j] +b[i]*y[j]

y[j] = -a[i]/b[i] * x[j] + g[j]/b[i]


// 凸包
 


f[i] 输出前i个数字 最小花费

f[i] = min(f[j] + (sum[i]-sum[j])^2 +M )
j<i

g[j] = f[j] + (sum[i]-sum[j])^2 +M 
g[j] = f[j] + sum[i]^2 + sum[j]^2 -2sum[i]sum[j] +M

f[j] + sum[j]^2  = 2sum[i] sum[j]  - sum[i]^2 + g[j] -M

y[j] = k[i]x[j] +g/b[i]


for(int i=1;i<=n;i++){
	int k = 2 * sum[i];
	int j = ask(k);
	f[i] = f[j] + (sum[i]-sum[j])*(sum[i]-sum[j]) + M;
	// x[i] =
	// y[i] =
	add(i); 
}

// f[0][0] = 1

// f[i][1] = 1





